#!/usr/bin/python
#
# For version 0.11:
# 1) What to do when you run a command twice?
#    Kill processes?  Just tell you?
#
# For version 0.2:
# 1) Dependencies instead of priorities?
# 2) Handling sln:
#   a) arguments for commands?
#   b) more than one of each command type?
#   c) Killing remote programs? (ie, the remote watch-file)
#
# Looking like this is a little mini proc filesystem with remote processes...
# Maybe I should just get more proficient with ps and kill...
#
# Thinking a bit more: remote killing is out b/c I have no reliable
# way to get the PIDs I'll just have to do that manually: Maybe make
# watch-file look for errors when writing to the socket + exit when
# there is one
#
# Start/Kill w/ regexps or globbing.
# 
# Could start procs w/ extended naems: ie, sln-gsn.eps or something.
# Could have second file which reads /tmp/ports + hacks it up in order
# to keep this simple.
#
# To make this work: Need kill w/ regexp, second one to start.

import getopt,sys,os,pickle,time

VERSION = 0.1

def snarf(cmd):
    """Run a shell gommand and grab the output as a string."""
    f=os.popen(cmd)
    result = f.readline()[:-1] # strip final newline
    f.close()
    return result

def ip_address(): return snarf('ip-address')
def todays_date(): return snarf('date +%y-%m-%d')

def socket_command():
    """Return command to do my socket-listening mail forwarding thing"""
    str = 'socket -l -d ~/.html -f %s-percentd.html %s 2025' % \
          (todays_date(), ip_address())
    return str.replace("percentd", "%d")

##################################################
# Info about running processes.  Dictionary where the keys are process
# names (strings), values are process id's (ints)
pids = {}

# Commands and priorities for executing them.  Dictionary of where the
# keys are process names (strings) and the values are dictionaries of
# command info.
#
# Command info dictionaries contain keys:
# 'command': command line to run the program (string)
# 'priority': (int) that determines the order in which to run the
#             tasks.  Lower numbers => run sooner.
# 'sleep_before': (int) seconds to sleep _before_ running this task
#                 (to allow some earlier thing to finish).
# 'sleep_after': (int) seconds to sleep _after_ running this task before
#                running any other tasks (because those tasks depend
#                on this one).

def cmd(command,priority=0,sleep_after=0, sleep_before=0):
    """Produce "Command info dictionary" with some defaults"""
    return dict(command=command, priority=priority,
                sleep_after=sleep_after, sleep_before=sleep_before)
    
commands = dict(
    dionysusssh =cmd('ssh -n -N -L2022:dionysus:22 ssh'),
    dionysusweb =cmd('ssh -n -N -L2080:dionysus:80 ssh'),
    dionysusmail=cmd('ssh -n -N -R2025:%s:2025 dionysus' % ip_address(),
                     priority=20, sleep_before=5),
    dionysussock=cmd(socket_command()),
    desktop=cmd('ssh -n -N -L2022:dionysus.ucolick.org:22 dionysus.ucolick.org'),
    sunhost     =cmd(command='ssh -n -N -L3022:publichost:22 ssh'),
    linuxhost   =cmd(command='ssh -n -N -L4022:rumba:22 ssh'),
    upsand      =cmd(command='ssh -n -N -L5022:upsand:22 andromeda.ucsc.edu'),
    twopiter    =cmd(command='ssh -n -N -L6022:twopiter:22 andromeda.ucsc.edu'),

    # Aliases   
    dionysus=['dionysusssh', 'dionysusweb', 'dionysusmail','dionysussock'],
    home=['dionysus'],
#    home=['dionysus', 'sunhost', 'linuxhost', 'twopiter', 'upsand'],    
    work=['twopiter','upsand']
    )

commands['all'] = commands.keys()
##################################################

def prioritize(name1, name2):
    """Sort named commands by priority"""
    if commands[name1]['priority'] == commands[name2]['priority']:
        return 0
    if commands[name1]['priority'] < commands[name2]['priority']:
        return -1
    if commands[name1]['priority'] > commands[name2]['priority']:
        return 1

def unprioritize(name1, name2):
    """Sort named commands by reverse priority"""
    if commands[name1]['priority'] == commands[name2]['priority']:
        return 0
    if commands[name1]['priority'] < commands[name2]['priority']:
        return 1
    if commands[name1]['priority'] > commands[name2]['priority']:
        return -1

def is_not_alias(name):
    """Return true if name is an alias for other commands rather
    than a command itself.  Used to filter out the aliases after
    they've been expaneded."""
    if type(commands[name]) is type([]):
        return False
    return True

def expand_aliases(names):
    """Expand commands that are really aliases for other commands"""
    # Check to make sure they're all there.
    for name in names:
        if not commands.has_key(name):
            print "No command for ", name
            print "Possibilities:"
            print commands.keys()
            sys.exit(1)
            
    #expand all aliases
    for name in names:
        if type(commands[name]) is type([]):
            names += commands[name]        
    #Now filter out the (expanded) aliases
    return uniqueify(filter(is_not_alias, names))
    
def uniqueify(names):
    """Given a list, return a new list with duplicate entries
    removed (order is not preserved)!"""
    if len(names) == 0: return []

    names = list(names)    # work on a copy
    names.sort()
    result = [names[0]]
    for name in names:
        if name != result[-1]: result.append(name)            
    return result

def run_processes(names):
    """Run the commands associated with a list of names"""
    global pids
    # if no args, list availalbe processes
    if len(names) == 0:
        print "Possibilities:"
        print commands.keys()
    else:
        names = list(names)
        names.sort(prioritize) # sort a copy
        for name in names:
            time.sleep(commands[name]['sleep_before'])
            pid = os.fork()
            if pid != 0: # parent
                pids[name] = pid
                print "Running %s, pid=%d: %s" % (name, pid,
                                                  commands[name]['command'])
            else: # child
                os.execl('/bin/sh','junk', '-c', commands[name]['command'])
            time.sleep(commands[name]['sleep_after'])
                
def kill_processes(names):
    """Kill the processes associated with a list of names"""
    # if no args, list availalbe processes
    if len(names):
        names = list(names)
        names.sort(unprioritize) # sort a copy
        for name in names:            
            if pids.has_key(name):
                print "Killing %s, pid %d" % (name, pids[name])
                os.system("kill %d" % pids[name])
                del pids[name]
            else:
                print "Couldn't find pid for ", name
    else:
        print "Running Processes:"
        print pids

def can(obj, file, *args, **kw):
    """Store an object in a file.  This is a slightly more compact
    form of the build-in 'pickle.'  It allows you to just give a
    filename and let this function open and close the file"""

    if type(file) is type('string'): f=open(file,'w')
    else: f=file

    pickle.dump(obj, f, *args, **kw)    

    if type(file) is type('string'): f.close()

def uncan(file, *args, **kw):
    """Read an object from a file.  This is a slightly more compact
    form of the build-in 'pickle.'  It allows you to just give a
    filename and let this function open and close the file"""
    # If filename, should this read until all exhausted?
    if type(file) is type('string'): f=open(file)
    else: f=file    

    obj = pickle.load(f, *args, **kw)    

    if type(file) is type('string'): f.close()

    return obj

def usage():
    print "Usage: ports [-k] [-h] [-v] [names]"
    print "       -h display this message"
    print "       -v display version"
    print "       -k to kill processes"
    print "       no swithces => run processes."
    print "       run 'ports' to see a list of possibilities"
    print "       run 'ports -k' to see a list of running processes"    

def main():
    """Where the action is"""
    global pids

    try: opts, args = getopt.getopt(sys.argv[1:],"hktv")
    except getopt.GetoptError:
        usage()
        sys.exit(1)
        
    # Figure out what to do
    run_flag = True
    
    for o,a in opts:
        if o == '-k': run_flag = False
        if o == '-v':
            print "Ports version ", VERSION
            sys.exit(0)
        if o == '-h':
            usage()
            sys.exit(1)

    # Try to load running pid table.
    # If none, create an empty one
    try: pids = uncan('/tmp/ports-pids')
    except IOError: pids = {}

    names = expand_aliases(args)
    
    if run_flag: run_processes(names)
    else: kill_processes(names)

    # write pid table
    can(pids, '/tmp/ports-pids')

main()
